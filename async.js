"use strict";

// 1. Є наступний код:

console.log("start"); // виводемо в консоль строку start

const promise1 = new Promise((resolve, reject) => {
  // ініціалізуємо нову змінну з назвою promise1
  // дана змінна є промісом, створена за допомогаю глобального класу Promise (new Promise є глобальним класом)
  // проміс є асинхронною функцією
  console.log(1); // виводимо в консоль строку зі значенням 1, це в нас перше успіщне виконання промісу
  resolve(2);
});

// викликаємо метод .then
// що приймає в собі аргумент, який є результатом успішного виконання promise1
// виконуємо console.log, але вже з аргументом, що в нас є в resolve
promise1.then((res) => {
  console.log(res);
});

console.log("end");

// результат в консолі буде start 1 end 2
// тобто виконується спочатку просто console.log("start"),
// потім promise1, console.log("end"),
// а вже після метод .then

// 2. Є наступний код:

Promise.resolve(1)
        // повертає нам проміс зі значеннм 1, консоль пуста
  .then((x) => x + 1)
        // метод .then повертає проміс, в собі приймає як рагумет результат попереднього промісу, тобто 1, консоль пуста
  .then((x) => { throw new Error('My Error') })
        // в даному випадку створюємо обʼєкт помилки, хоча ми і приймаємо за аргумент х результат попередного .then, не використовуюємо його
  .catch(() => 1)
        // метод, що обробляє помилки, ми перехоплюємо помилку, що видав попередній проміс, а як результат передали 1
  .then((x) => x + 1)
        // приймаємо як аршумент попередній результат, тобто 1, та виконуємо функцію, тобто додаємо 1
  .then((x) => console.log(x))
        // виконуємо функцію з аргументом, що є результатом попередньої функції
  .catch(console.error)
        // це в нас обробник помилки, точніше метод, що обробляє помилку, але так як на попередньому кроці помилки не було, то він не спрацює
        // результат в сонсолі просто 2

// 3. Є наступний код:

const promise = new Promise((res) => res(2));
// ініціалізуємо констранту promise, що є інстенсом від класу Promise
// в консоль нічого не виводиться, в нас просто є аргумент зі значення 2

promise
  .then((v) => { 
    //  метод виконується з аргументом v, значення якого є результатом попереднього виконання при успішному виконанні 
    console.log(v); //  виводимо у консоль значення v, тобто просто 2
    return v * 2; //  множимо це значення на 2, отримаємо 4 
  })

  .then((v) => {
    //  метод виконується з аргументом v, значення якого є результатом попереднього виконання при успішному виконанні 
    console.log(v); //  виводимо у консоль значення v, тобто просто 4
    return v * 2; //  множимо це значення на 2, отримаємо 8 
  })
  .finally((v) => {   //  метод виконується  при будь якому виконанні  (успішно або з помилкою) попереднього промісу 
    // але метод finally не має параметрів
 console.log(v); //  виводимо у консоль значення v, але ми його не передали, бо finally не має параметрів , того у консолі undefined
    return v * 2;
  })
    .then(v => { //  метод виконується з аргументом v, значення якого є результатом попереднього виконання при успішному виконанні 
        console.log(v); // того він і приймає останній успішний результа як аргумент і далі його використовую , торимуємо 8 у консолі 
    });